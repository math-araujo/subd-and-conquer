#include "subdivision.hpp"
#include "geometrycentral/surface/surface_mesh_factories.h"
#include "geometrycentral/utilities/vector3.h"

namespace geometry::subdivision
{

Halfedge standard_catmull_clark(const Halfedge& halfedge)
{
    geometrycentral::surface::ManifoldSurfaceMesh* mesh{halfedge.mesh.get()};
    geometrycentral::surface::VertexPositionGeometry* geometry{halfedge.geometry.get()};

    std::vector<geometrycentral::Vector3> new_points;
    new_points.reserve(mesh->nFaces() + mesh->nEdges() + mesh->nVertices());
    // Maps the face f to the index of it's corresponding new point in the new_points vector
    // i.e. new_points[old_face_new_point_index[f]] stores the new point generated by f
    std::unordered_map<geometrycentral::surface::Face, std::size_t> old_face_new_point_index;

    for (std::size_t face_id = 0; geometrycentral::surface::Face face : mesh->faces())
    {
        auto new_face_point{geometrycentral::Vector3::zero()};
        std::size_t num_vertices{0};
        for (geometrycentral::surface::Vertex vertex : face.adjacentVertices())
        {
            new_face_point += geometry->vertexPositions[vertex];
            ++num_vertices;
        }
        old_face_new_point_index.emplace(face, new_points.size());
        new_points.emplace_back(new_face_point / num_vertices);
        ++face_id;
    }

    // For each edge, add an edge point
    std::unordered_map<geometrycentral::surface::Edge, std::size_t> old_edge_new_point_index;
    std::unordered_map<geometrycentral::surface::Edge, geometrycentral::Vector3> old_edge_midpoints;
    for (std::size_t edge_id = 0; geometrycentral::surface::Edge edge : mesh->edges())
    {
        if (edge.isBoundary())
        {
            throw std::runtime_error{"Runtime error - Standard Catmull-Clark does not support meshes with boundaries"};
        }
        const auto endpoints_sum{geometry->vertexPositions[edge.secondVertex()] +
                                 geometry->vertexPositions[edge.firstVertex()]};
        old_edge_midpoints.emplace(edge, endpoints_sum / 2);

        auto new_edge_point{geometrycentral::Vector3::zero()};
        new_edge_point += endpoints_sum;
        for (geometrycentral::surface::Face face : edge.adjacentFaces())
        {
            new_edge_point += new_points[old_face_new_point_index[face]];
        }
        old_edge_new_point_index.emplace(edge, new_points.size());
        new_points.emplace_back(new_edge_point / 4.0);
        ++edge_id;
    }

    std::unordered_map<geometrycentral::surface::Vertex, std::size_t> old_vertex_new_point_index;
    for (std::size_t vertex_id = 0; geometrycentral::surface::Vertex vertex : mesh->vertices())
    {
        if (vertex.isBoundary())
        {
            throw std::runtime_error{"Runtime error - Standard Catmull-Clark does not support meshes with boundaries"};
        }

        // Computes the variable "Q" of the paper.
        auto avg_new_face_points{geometrycentral::Vector3::zero()};
        std::size_t num_faces{0};
        for (geometrycentral::surface::Face face : vertex.adjacentFaces())
        {
            avg_new_face_points += new_points[old_face_new_point_index[face]];
            ++num_faces;
        }
        avg_new_face_points /= num_faces;
        ++vertex_id;

        // Computes the variable "R" of the paper.
        auto avg_old_edge_midpoints{geometrycentral::Vector3::zero()};
        std::size_t num_edges{0};
        for (geometrycentral::surface::Edge edge : vertex.adjacentEdges())
        {
            avg_old_edge_midpoints += old_edge_midpoints[edge];
            ++num_edges;
        }
        avg_old_edge_midpoints /= num_edges;

        if (num_faces != num_edges)
        {
            throw std::runtime_error{"Runtime Error - Vertex with num_faces != num_edges"};
        }

        // The old vertex point is the variable "S" of the paper.
        const auto& current_vertex{geometry->vertexPositions[vertex]};
        old_vertex_new_point_index.emplace(vertex, new_points.size());

        // Implements the formula on the paper: (Q / n) + (2 * R / n) + (S * (n - 3) / n)
        new_points.emplace_back((avg_new_face_points / num_faces) + (2 * avg_old_edge_midpoints / num_faces) +
                                ((static_cast<double>(num_faces - 3) / (num_faces)) * current_vertex));
    }

    // Quadrangulate faces
    std::vector<std::vector<std::size_t>> new_faces_indices;
    for (geometrycentral::surface::Face face : mesh->faces())
    {
        const std::size_t new_face_index{old_face_new_point_index[face]};
        /*
        To construct the new faces (quadrangulate the original face), for each vertex v on face f,
        we need access to both the outcoming halfedge of v (i.e., the halfedge with v as tail) and
        the incoming halfedge incoming on v (i.e., the halfedge with v as tip).
        The following loop find and stores the incoming halfedges of each vertex of a face for
        faster access on the subsequent loop (the one that assemble the new face's indices).
        */
        std::unordered_map<geometrycentral::surface::Vertex, geometrycentral::surface::Edge> incident_edge;
        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            incident_edge.emplace(halfedge.tipVertex(), halfedge.edge());
        }

        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            new_faces_indices.emplace_back(std::vector<std::size_t>{
                old_vertex_new_point_index[halfedge.vertex()], old_edge_new_point_index[halfedge.edge()],
                new_face_index, old_edge_new_point_index[incident_edge[halfedge.vertex()]]});
        }
    }

    auto [subd_mesh, subd_geometry] =
        geometrycentral::surface::makeManifoldSurfaceMeshAndGeometry(new_faces_indices, new_points);
    return Halfedge{.mesh = std::move(subd_mesh), .geometry = std::move(subd_geometry)};
}

Halfedge derose_catmull_clark(const Halfedge& halfedge)
{
    geometrycentral::surface::ManifoldSurfaceMesh* mesh{halfedge.mesh.get()};
    geometrycentral::surface::VertexPositionGeometry* geometry{halfedge.geometry.get()};

    std::vector<geometrycentral::Vector3> new_points;
    new_points.reserve(mesh->nFaces() + mesh->nEdges() + mesh->nVertices());
    // Maps the face f to the index of it's corresponding new point in the new_points vector
    // i.e. new_points[old_face_new_point_index[f]] stores the new point generated by f
    std::unordered_map<geometrycentral::surface::Face, std::size_t> old_face_new_point_index;

    for (std::size_t face_id = 0; geometrycentral::surface::Face face : mesh->faces())
    {
        auto new_face_point{geometrycentral::Vector3::zero()};
        std::size_t num_vertices{0};
        for (geometrycentral::surface::Vertex vertex : face.adjacentVertices())
        {
            new_face_point += geometry->vertexPositions[vertex];
            ++num_vertices;
        }
        old_face_new_point_index.emplace(face, new_points.size());
        new_points.emplace_back(new_face_point / num_vertices);
        ++face_id;
    }

    // For each edge, add an edge point
    std::unordered_map<geometrycentral::surface::Edge, std::size_t> old_edge_new_point_index;
    for (std::size_t edge_id = 0; geometrycentral::surface::Edge edge : mesh->edges())
    {
        old_edge_new_point_index.emplace(edge, new_points.size());
        const auto endpoints_sum{geometry->vertexPositions[edge.secondVertex()] +
                                 geometry->vertexPositions[edge.firstVertex()]};
        if (edge.isBoundary())
        {
            // If edge is boundary edge, implements formula (8) of the paper
            new_points.emplace_back(endpoints_sum / 2.0);
        }
        else
        {
            // If edge is not boundary edge, implements formula (1) of the paper
            auto new_edge_point{endpoints_sum};
            for (geometrycentral::surface::Face face : edge.adjacentFaces())
            {
                new_edge_point += new_points[old_face_new_point_index[face]];
            }
            new_points.emplace_back(new_edge_point / 4.0);
            ++edge_id;
        }
    }

    std::unordered_map<geometrycentral::surface::Vertex, std::size_t> old_vertex_new_point_index;
    for (std::size_t vertex_id = 0; geometrycentral::surface::Vertex vertex : mesh->vertices())
    {
        old_vertex_new_point_index.emplace(vertex, new_points.size());

        // If vertex is boundary vertex, implements formula (9) of the paper
        if (vertex.isBoundary())
        {
            const geometrycentral::Vector3 current_vertex{geometry->vertexPositions[vertex]};
            auto weighted_sum{6.0 * current_vertex};

            int incoming_boundary_edges{0};
            for (geometrycentral::surface::Halfedge incoming_halfedge : vertex.incomingHalfedges())
            {
                if (incoming_halfedge.edge().isBoundary())
                {
                    weighted_sum += geometry->vertexPositions[incoming_halfedge.vertex()];
                    ++incoming_boundary_edges;
                }
            }

            // Per appendix A, boundary vertices with more than two incident sharp/boundary edges
            // are corner vertices and should not move at all. Otherwise, apply formula (9).
            if (incoming_boundary_edges > 2)
            {
                new_points.emplace_back(current_vertex);
            }
            else
            {
                new_points.emplace_back(weighted_sum / 8.0);
            }
        }
        else // If vertex is not a boundary vertex, implements formula (2) of the paper
        {
            auto avg_vertices_neighbors{geometrycentral::Vector3::zero()};
            std::size_t num_edges{0};
            for (geometrycentral::surface::Vertex neighbor_vertex : vertex.adjacentVertices())
            {
                avg_vertices_neighbors += geometry->vertexPositions[neighbor_vertex];
                ++num_edges;
            }
            avg_vertices_neighbors /= (num_edges * num_edges);

            auto avg_new_face_points{geometrycentral::Vector3::zero()};
            std::size_t num_faces{0};
            for (geometrycentral::surface::Face face : vertex.adjacentFaces())
            {
                avg_new_face_points += new_points[old_face_new_point_index[face]];
                ++num_faces;
            }
            avg_new_face_points /= (num_edges * num_edges);

            ++vertex_id;

            if (num_faces != num_edges)
            {
                throw std::runtime_error{"Runtime Error - Interior vertex with num_faces != num_edges"};
            }

            const auto& current_vertex{geometry->vertexPositions[vertex]};

            new_points.emplace_back(((static_cast<double>(num_edges - 2) / (num_edges)) * current_vertex) +
                                    (avg_vertices_neighbors) + (avg_new_face_points));
        }
    }

    // Quadrangulate faces
    std::vector<std::vector<std::size_t>> new_faces_indices;
    for (geometrycentral::surface::Face face : mesh->faces())
    {
        const std::size_t new_face_index{old_face_new_point_index[face]};
        /*
        To construct the new faces (quadrangulate the original face), for each vertex v on face f,
        we need access to both the outcoming halfedge of v (i.e., the halfedge with v as tail) and
        the incoming halfedge incoming on v (i.e., the halfedge with v as tip).
        The following loop find and stores the incoming halfedges of each vertex of a face for
        faster access on the subsequent loop (the one that assemble the new face's indices).
        */
        std::unordered_map<geometrycentral::surface::Vertex, geometrycentral::surface::Edge> incident_edge;
        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            incident_edge.emplace(halfedge.tipVertex(), halfedge.edge());
        }

        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            new_faces_indices.emplace_back(std::vector<std::size_t>{
                old_vertex_new_point_index[halfedge.vertex()], old_edge_new_point_index[halfedge.edge()],
                new_face_index, old_edge_new_point_index[incident_edge[halfedge.vertex()]]});
        }
    }

    auto [subd_mesh, subd_geometry] =
        geometrycentral::surface::makeManifoldSurfaceMeshAndGeometry(new_faces_indices, new_points);
    return Halfedge{.mesh = std::move(subd_mesh), .geometry = std::move(subd_geometry)};
}

} // namespace geometry::subdivision