#include "subdivision.hpp"
#include "geometrycentral/surface/surface_mesh_factories.h"
#include "geometrycentral/utilities/vector3.h"

namespace geometry::subdivision
{

Halfedge standard_catmull_clark(const Halfedge& halfedge)
{
    geometrycentral::surface::ManifoldSurfaceMesh* mesh{halfedge.mesh.get()};
    geometrycentral::surface::VertexPositionGeometry* geometry{halfedge.geometry.get()};

    std::vector<geometrycentral::Vector3> new_points;
    new_points.reserve(mesh->nFaces() + mesh->nEdges() + mesh->nVertices());
    // Maps the face f to the index of it's corresponding new point in the new_points vector
    // i.e. new_points[old_face_new_point_index[f]] stores the new point generated by f
    std::unordered_map<geometrycentral::surface::Face, std::size_t> old_face_new_point_index;

    for (std::size_t face_id = 0; geometrycentral::surface::Face face : mesh->faces())
    {
        auto new_face_point{geometrycentral::Vector3::zero()};
        std::size_t num_vertices{0};
        for (geometrycentral::surface::Vertex vertex : face.adjacentVertices())
        {
            new_face_point += geometry->vertexPositions[vertex];
            ++num_vertices;
        }
        old_face_new_point_index.emplace(face, new_points.size());
        new_points.emplace_back(new_face_point / num_vertices);
        ++face_id;
    }

    // For each edge, add an edge point
    std::unordered_map<geometrycentral::surface::Edge, std::size_t> old_edge_new_point_index;
    std::unordered_map<geometrycentral::surface::Edge, geometrycentral::Vector3> old_edge_midpoints;
    for (std::size_t edge_id = 0; geometrycentral::surface::Edge edge : mesh->edges())
    {
        if (edge.isBoundary())
        {
            throw std::runtime_error{"Runtime error - Standard Catmull-Clark does not support meshes with boundaries"};
        }
        const auto endpoints_sum{geometry->vertexPositions[edge.secondVertex()] +
                                 geometry->vertexPositions[edge.firstVertex()]};
        old_edge_midpoints.emplace(edge, endpoints_sum / 2);

        auto new_edge_point{geometrycentral::Vector3::zero()};
        new_edge_point += endpoints_sum;
        for (geometrycentral::surface::Face face : edge.adjacentFaces())
        {
            new_edge_point += new_points[old_face_new_point_index[face]];
        }
        old_edge_new_point_index.emplace(edge, new_points.size());
        new_points.emplace_back(new_edge_point / 4.0);
        ++edge_id;
    }

    std::unordered_map<geometrycentral::surface::Vertex, std::size_t> old_vertex_new_point_index;
    for (std::size_t vertex_id = 0; geometrycentral::surface::Vertex vertex : mesh->vertices())
    {
        if (vertex.isBoundary())
        {
            throw std::runtime_error{"Runtime error - Standard Catmull-Clark does not support meshes with boundaries"};
        }

        // Computes the variable "Q" of the paper.
        auto avg_new_face_points{geometrycentral::Vector3::zero()};
        std::size_t num_faces{0};
        for (geometrycentral::surface::Face face : vertex.adjacentFaces())
        {
            avg_new_face_points += new_points[old_face_new_point_index[face]];
            ++num_faces;
        }
        avg_new_face_points /= num_faces;
        ++vertex_id;

        // Computes the variable "R" of the paper.
        auto avg_old_edge_midpoints{geometrycentral::Vector3::zero()};
        std::size_t num_edges{0};
        for (geometrycentral::surface::Edge edge : vertex.adjacentEdges())
        {
            avg_old_edge_midpoints += old_edge_midpoints[edge];
            ++num_edges;
        }
        avg_old_edge_midpoints /= num_edges;
        if (num_faces != num_edges)
        {
            throw std::runtime_error{"Runtime Error - num_faces != num_edges"};
        }

        // The old vertex point is the variable "S" of the paper.
        const auto& current_vertex{geometry->vertexPositions[vertex]};
        old_vertex_new_point_index.emplace(vertex, new_points.size());

        // Implements the formula on the paper: (Q / n) + (2 * R / n) + (S * (n - 3) / n)
        new_points.emplace_back((avg_new_face_points / num_faces) + (2 * avg_old_edge_midpoints / num_faces) +
                                ((static_cast<double>(num_faces - 3) / (num_faces)) * current_vertex));
    }

    // Quadrangulate faces
    std::vector<std::vector<std::size_t>> new_faces_indices;
    for (geometrycentral::surface::Face face : mesh->faces())
    {
        const std::size_t new_face_index{old_face_new_point_index[face]};
        /*
        To construct the new faces (quadrangulate the original face), for each vertex v on face f,
        we need access to both the outcoming halfedge of v (i.e., the halfedge with v as tail) and
        the incoming halfedge incoming on v (i.e., the halfedge with v as tip).
        The following loop find and stores the incoming halfedges of each vertex of a face for
        faster access on the subsequent loop (the one that assemble the new face's indices).
        */
        std::unordered_map<geometrycentral::surface::Vertex, geometrycentral::surface::Edge> incident_edge;
        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            incident_edge.emplace(halfedge.tipVertex(), halfedge.edge());
        }

        for (geometrycentral::surface::Halfedge halfedge : face.adjacentHalfedges())
        {
            new_faces_indices.emplace_back(std::vector<std::size_t>{
                old_vertex_new_point_index[halfedge.vertex()], old_edge_new_point_index[halfedge.edge()],
                new_face_index, old_edge_new_point_index[incident_edge[halfedge.vertex()]]});
        }
    }

    auto [subd_mesh, subd_geometry] =
        geometrycentral::surface::makeManifoldSurfaceMeshAndGeometry(new_faces_indices, new_points);
    return Halfedge{.mesh = std::move(subd_mesh), .geometry = std::move(subd_geometry)};
}

} // namespace geometry::subdivision